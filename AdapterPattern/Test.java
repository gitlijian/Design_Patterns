package DesignPattern.AdapterPattern;

/**适配器模式的主要作用是将一个接口转换为另一种接口，类似于转接线。
 * 使得本来不适用于另一个系统的接口经过适配器，可以应用于另一个系统
 * 适配器：将一个接口转变成用户所希望的形式，使得原本不兼容的类可以一起工作
 *
 *
 * 适配器与桥接模式：
 *    桥接：分离抽象化和实现，桥接模式是当我们什么都没实现时，想把一个模块分开实现时，可以使用桥接模式。所以桥接模式
 *    是先有桥，再有两端实现
 *    适配器则是先有两端的实现，需要两者配合工作时，使用适配器让两者相容。
 * 适配器与装饰者模式：
 *    装饰者：将对象包装，同时赋予他们新的职责---那装饰者和代理模式的区别？ 装饰者和外观模式的区别？
 *    适配器：将对象包装，使他们看起来像别的东西
 * 适配器与外观模式：通常来说一个适配器仅适配一种接口，但是当我们需要用一个适配器适配多个接口时，就引出了外观模式
 *    外观：让我们的接口变得更简单，让多个接口方法的调用放到一个方法中，对外提供。使得用户从组件的子系统中脱离
 *    适配器：将接口转化为用户所需要的接口，此时用户还是和子系统耦合在一起。
 *    比如，家庭影院，需要调整灯光，开DVD，放影片等等，外观可以把这三个步骤封装一下对用户提供，用户不需要再调用灯光、DVD等部分的方法
 *    而只需要使用外观的一个api即可。而适配器则是用于，当我们客户想调整灯光时，如果灯光系统提供的api不为用户代码接受的时候
 *    使用适配器来调整
 * 适配器与代理模式：
 *    代理：虽然也是包装对象，代理的接口和原本类的接口是一模一样的，只是来增强原本类中的方法，所以不能改变接口的使用对象
 *
 * 装饰者和代理的区别：
 *     代理：包装了一个对象，对其进行增强，很多时候是负责进行一些参数的验证，判断是否有调用真正对象的资格等等
 *     装饰者：不做验证，只是纯粹的增强真正对象的某个方法。
 * 适配器模式用于当几个类的作用相似或者相同，但是接口不同时，如果一个类想可以都使用他们，就可以使用适配器模式。
 * 上层只需要调用适配器中的api，适配器内部根据用户的选择，再选择对应的类的接口。
 * 应用：jdbc
 * 适配器一般用于第三方应用类库为了其他使用而不想改变自己的接口时使用
 * 项目初期一般重构接口，而不需要使用适配器
 * 适配器一般都是两个成熟的系统，当两者相一起工作，但是接口不兼容时才会考虑。
 */
public class Test {
    public static void main(String[] args) {
        DriverManager driverManager = new DriverManager();
        MyJdbc myJdbc = driverManager.getConn("mysql");
        myJdbc.select();
        myJdbc.add();

        myJdbc = driverManager.getConn("oracle");
        myJdbc.select();
    }
}
